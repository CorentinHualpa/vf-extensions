/**
 *  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 *  ‚ïë  DownloadReport ‚Äì ChatInnov Edition Multilingue           ‚ïë
 *  ‚ïë                                                           ‚ïë
 *  ‚ïë  ‚Ä¢ Support JSON et TEXT                                   ‚ïë
 *  ‚ïë  ‚Ä¢ T√©l√©chargement : HTML / PDF / Markdown                ‚ïë
 *  ‚ïë  ‚Ä¢ Copie : Format√© (riche) / Brut                        ‚ïë
 *  ‚ïë  ‚Ä¢ Support FR/EN                                         ‚ïë
 *  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 */

export const DownloadReport = {
  name: 'DownloadReport',
  type: 'response',
  
  match: ({ trace }) => trace.type === 'download_report' || trace.payload?.type === 'download_report',

  render: ({ trace, element }) => {
    try {
      // Traductions
      const translations = {
        fr: {
          copy: {
            buttonTitle: 'Copier',
            formatOption: 'Format√©',
            formatTooltip: 'Copier avec la mise en forme',
            rawOption: 'Brut',
            rawTooltip: 'Copier le texte brut',
            toastFormatted: 'Copi√© avec formatage',
            toastRaw: 'Texte copi√©',
            toastError: 'Erreur lors de la copie'
          },
          download: {
            buttonTitle: 'T√©l√©charger le rapport',
            toastHTML: 'Rapport ouvert dans un nouvel onglet',
            toastPDF: 'PDF t√©l√©charg√© avec succ√®s',
            toastMarkdown: 'Markdown t√©l√©charg√© avec succ√®s',
            toastError: 'Erreur lors de la g√©n√©ration'
          },
          report: {
            generationDate: 'Date de g√©n√©ration',
            at: '√†',
            generatedBy: '¬© ChatInnov - Rapport g√©n√©r√© automatiquement',
            generatedByShort: 'Rapport g√©n√©r√© par ChatInnov'
          }
        },
        en: {
          copy: {
            buttonTitle: 'Copy',
            formatOption: 'Formatted',
            formatTooltip: 'Copy with formatting',
            rawOption: 'Raw',
            rawTooltip: 'Copy plain text',
            toastFormatted: 'Copied with formatting',
            toastRaw: 'Text copied',
            toastError: 'Copy error'
          },
          download: {
            buttonTitle: 'Download report',
            toastHTML: 'Report opened in new tab',
            toastPDF: 'PDF downloaded successfully',
            toastMarkdown: 'Markdown downloaded successfully',
            toastError: 'Generation error'
          },
          report: {
            generationDate: 'Generation date',
            at: 'at',
            generatedBy: '¬© ChatInnov - Automatically generated report',
            generatedByShort: 'Report generated by ChatInnov'
          }
        }
      };

      // Configuration par d√©faut
      const defaultConfig = {
        marketTitle: 'Analyse de March√©',
        content: '',
        fileName: 'chatinnov_rapport',
        url_logo: 'https://i.imgur.com/qWcV9Z9.png',
        presentation_text: "L'IA GENERATIVE AU SERVICE DE L'INTELLIGENCE DES MARCH√âS ET DE L'INNOVATION √Ä IMPACT",
        accentColor: '#666666',
        downloadIconText: 'üì•',
        copyIconText: 'üìã',
        copiedIcon: '‚úÖ',
        formats: ['html', 'pdf', 'md'],
        showCopyButton: true,
        showDownloadButton: true,
        langue: 'fr'
      };

      // Parser le payload
      let config = { ...defaultConfig };
      
      if (typeof trace.payload === 'string') {
        try {
          let cleanPayload = trace.payload.trim();
          
          // Si c'est du JSON (commence par {)
          if (cleanPayload.startsWith('{')) {
            try {
              const parsed = JSON.parse(cleanPayload);
              config = { ...defaultConfig, ...parsed };
            } catch (e) {
              console.log('Tentative de nettoyage du JSON...');
              
              // Parsing manuel en cas d'√©chec
              const marketTitleMatch = cleanPayload.match(/"marketTitle"\s*:\s*"([^"]+)"/);
              const fileNameMatch = cleanPayload.match(/"fileName"\s*:\s*"([^"]+)"/);
              const urlLogoMatch = cleanPayload.match(/"url_logo"\s*:\s*"([^"]+)"/);
              const presentationMatch = cleanPayload.match(/"presentation_text"\s*:\s*"([^"]+)"/);
              const contentMatch = cleanPayload.match(/"content"\s*:\s*"([\s\S]*?)"\s*,\s*"[^"]+"\s*:/);
              const langueMatch = cleanPayload.match(/"langue"\s*:\s*"([^"]+)"/);
              
              if (marketTitleMatch) config.marketTitle = marketTitleMatch[1];
              if (fileNameMatch) config.fileName = fileNameMatch[1];
              if (urlLogoMatch) config.url_logo = urlLogoMatch[1];
              if (presentationMatch) config.presentation_text = presentationMatch[1];
              if (langueMatch) config.langue = langueMatch[1];
              if (contentMatch) {
                config.content = contentMatch[1]
                  .replace(/\\n/g, '\n')
                  .replace(/\\"/g, '"')
                  .replace(/\\/g, '');
              }
            }
          } else {
            // MODE TEXT avec options
            const parts = cleanPayload.split('###OPTIONS###');
            
            // Le contenu est la premi√®re partie
            config.content = parts[0].trim();
            
            // IMPORTANT : S'assurer que la partie OPTIONS n'appara√Æt pas dans le contenu
            if (config.content.includes('###OPTIONS###')) {
              config.content = config.content.split('###OPTIONS###')[0].trim();
            }
            
            // Parser les options si pr√©sentes
            if (parts[1]) {
              const optionsText = parts[1].trim();
              const lines = optionsText.split('\n');
              
              lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine && trimmedLine.includes('=')) {
                  const [key, ...valueParts] = trimmedLine.split('=');
                  const value = valueParts.join('=').trim();
                  const cleanKey = key.trim();
                  
                  // Conversion des types
                  if (value === 'true') {
                    config[cleanKey] = true;
                  } else if (value === 'false') {
                    config[cleanKey] = false;
                  } else if (cleanKey === 'formats' && value.includes(',')) {
                    config[cleanKey] = value.split(',').map(f => f.trim());
                  } else {
                    config[cleanKey] = value;
                  }
                }
              });
            }
            
            console.log('Mode TEXT - Config finale:', config);
          }
        } catch (error) {
          console.error('Erreur de parsing:', error);
          config.content = trace.payload;
        }
      } else if (typeof trace.payload === 'object' && trace.payload !== null) {
        config = { ...defaultConfig, ...trace.payload };
      }

      // V√©rifier si on a du contenu
      if (!config.content || config.content.trim() === '') {
        console.warn('DownloadReport: Aucun contenu fourni');
        return;
      }

      // V√©rifier si au moins un bouton doit √™tre affich√©
      if (!config.showCopyButton && !config.showDownloadButton) {
        console.warn('DownloadReport: Aucun bouton √† afficher');
        return;
      }

      // S√©lectionner la bonne langue
      const lang = config.langue === 'en' ? 'en' : 'fr';
      const t = translations[lang];

      // Container principal pour les boutons
      const container = document.createElement('div');
      container.className = 'report-actions-container';
      
      // Styles minimalistes unifi√©s
      const styleEl = document.createElement('style');
      styleEl.textContent = `
        /* Container principal pour les actions */
        .report-actions-container {
          display: inline-flex !important;
          gap: 8px !important;
          align-items: center !important;
          margin: -0.75rem 0 0.5rem 0 !important;
          justify-content: flex-end !important;
          width: 100% !important;
        }

        /* Wrapper commun pour les boutons */
        .action-button-wrapper {
          position: relative !important;
          display: inline-flex !important;
          align-items: center !important;
        }

        /* Style commun pour tous les boutons */
        .action-button {
          background: transparent !important;
          color: ${config.accentColor} !important;
          border: 1px solid transparent !important;
          padding: 4px 8px !important;
          border-radius: 6px !important;
          font-size: 16px !important;
          cursor: pointer !important;
          display: inline-flex !important;
          align-items: center !important;
          justify-content: center !important;
          transition: all 0.2s ease !important;
          min-width: 32px !important;
          height: 32px !important;
        }

        .action-button:hover {
          background: rgba(0, 0, 0, 0.05) !important;
          border-color: rgba(0, 0, 0, 0.1) !important;
        }

        /* √âtat copi√© */
        .action-button.copied {
          color: #4CAF50 !important;
        }

        /* Ic√¥ne des boutons */
        .action-button-icon {
          font-size: 16px !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: all 0.2s ease !important;
        }

        .action-button:hover .action-button-icon {
          opacity: 1 !important;
        }

        /* Menu d√©roulant commun */
        .action-menu {
          position: absolute !important;
          top: calc(100% + 2px) !important;
          right: 0 !important;
          background: white !important;
          border: 1px solid #e0e0e0 !important;
          border-radius: 6px !important;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
          padding: 2px !important;
          z-index: 1000 !important;
          opacity: 0 !important;
          visibility: hidden !important;
          transition: all 0.15s ease !important;
          min-width: auto !important;
        }

        .action-menu.show {
          opacity: 1 !important;
          visibility: visible !important;
        }

        /* Options du menu */
        .action-menu-option {
          display: flex !important;
          align-items: center !important;
          gap: 6px !important;
          padding: 6px 12px !important;
          border: none !important;
          background: none !important;
          color: #333 !important;
          font-size: 12px !important;
          cursor: pointer !important;
          border-radius: 4px !important;
          transition: all 0.1s ease !important;
          width: 100% !important;
          text-align: left !important;
          white-space: nowrap !important;
        }

        .action-menu-option:hover {
          background: #f0f0f0 !important;
        }

        .action-menu-option-icon {
          opacity: 0.8 !important;
          font-size: 14px !important;
        }

        /* S√©parateur dans les menus */
        .action-menu-option + .action-menu-option {
          border-top: 1px solid #f0f0f0 !important;
        }

        /* √âtat de g√©n√©ration */
        .action-button.generating {
          opacity: 0.6 !important;
          cursor: wait !important;
        }

        .action-button.generating .action-button-icon {
          animation: spin 1s linear infinite !important;
        }

        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }

        /* Toast de notification unifi√© */
        .action-toast {
          position: fixed !important;
          bottom: 20px !important;
          right: 20px !important;
          background: rgba(0,0,0,0.8) !important;
          color: white !important;
          padding: 8px 16px !important;
          border-radius: 6px !important;
          font-size: 13px !important;
          box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
          z-index: 10000 !important;
          opacity: 0 !important;
          transform: translateY(10px) !important;
          transition: all 0.2s ease !important;
          pointer-events: none !important;
        }

        .action-toast.show {
          opacity: 1 !important;
          transform: translateY(0) !important;
        }

        /* Masquer le background gris du message Voiceflow */
        .vfrc-message--extension-DownloadReport {
          background: transparent !important;
          padding: 0 !important;
          margin: 0 !important;
          border: none !important;
          box-shadow: none !important;
        }

        /* Animation d'entr√©e */
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        .action-button {
          animation: fadeIn 0.3s ease-out !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
          .action-button {
            padding: 6px !important;
            min-width: 28px !important;
            height: 28px !important;
          }
          
          .action-button-icon {
            font-size: 14px !important;
          }
        }
      `;

      container.appendChild(styleEl);

      // Toast de notification partag√©
      let toast = document.querySelector('.action-toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.className = 'action-toast';
        document.body.appendChild(toast);
      }

      // Fonction pour afficher le toast
      const showToast = (message) => {
        toast.textContent = message;
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, 1500);
      };

      // Variables pour g√©rer l'√©tat des menus
      let copyMenuVisible = false;
      let downloadMenuVisible = false;

      // Fonction pour convertir un tableau HTML en Markdown
      const tableToMarkdown = (tableHtml) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = tableHtml;
        const table = tempDiv.querySelector('table');
        
        if (!table) return tableHtml;
        
        let markdown = '\n\n';
        
        const caption = table.querySelector('caption');
        if (caption) {
          markdown += `**${caption.textContent.trim()}**\n\n`;
        }
        
        const headers = Array.from(table.querySelectorAll('thead th, tbody tr:first-child th')).map(th => th.textContent.trim());
        if (headers.length === 0) {
          const firstRow = table.querySelector('tr');
          if (firstRow) {
            headers.push(...Array.from(firstRow.querySelectorAll('td, th')).map(cell => cell.textContent.trim()));
          }
        }
        
        if (headers.length > 0) {
          markdown += '| ' + headers.join(' | ') + ' |\n';
          markdown += '| ' + headers.map(() => '---').join(' | ') + ' |\n';
        }
        
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
          const cells = Array.from(row.querySelectorAll('td'));
          if (cells.length > 0) {
            markdown += '| ' + cells.map(cell => cell.textContent.trim()).join(' | ') + ' |\n';
          }
        });
        
        const footer = table.querySelector('tfoot');
        if (footer) {
          markdown += `\n*${footer.textContent.trim()}*\n`;
        }
        
        return markdown + '\n';
      };

      // Fonction pour g√©n√©rer le HTML
      const generateHTML = () => {
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US', {
          day: '2-digit',
          month: 'long',
          year: 'numeric'
        });
        const timeStr = date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US', {
          hour: '2-digit',
          minute: '2-digit'
        });
        
        let htmlContent = config.content;
        
        if (!htmlContent.includes('<')) {
          htmlContent = htmlContent
            .split('\n')
            .map(line => {
              line = line.trim();
              if (!line) return '';
              
              if (line.startsWith('üî∑')) {
                return `<h2><span class="no-gradient">üî∑</span> ${line.substring(2).trim()}</h2>`;
              }
              if (line.startsWith('üîπ')) {
                return `<h3><span class="no-gradient">üîπ</span> ${line.substring(2).trim()}</h3>`;
              }
              
              if (/^\d+\./.test(line) && line.length < 100) {
                return `<h4>${line}</h4>`;
              }
              
              if (line.startsWith('‚Ä¢') || line.startsWith('-')) {
                return `<li>${line.substring(1).trim()}</li>`;
              }
              
              line = line.replace(/([A-Za-z]+)\s*‚Äì\s*([^(]+)\s*\(([^)]+)\)/g, 
                '<a href="$3" target="_blank">$1 ‚Äì $2</a>');
              
              return `<p>${line}</p>`;
            })
            .join('\n')
            .replace(/<li>/g, '<ul><li>')
            .replace(/<\/li>\n(?!<li>)/g, '</li></ul>\n');
        }
        
        const html = `<!DOCTYPE html>
<html lang="${lang}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${config.marketTitle} - ChatInnov</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      line-height: 1.6;
      color: #333;
      background: #ffffff;
    }
    
    .header {
      background: white;
      padding: 20px 40px;
      border-bottom: 1px solid #eee;
    }
    
    .logo-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .logo {
      height: 50px;
      width: auto;
    }
    
    .tagline {
      color: #7c3aed;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      text-align: right;
      max-width: 400px;
    }
    
    .hero-banner {
      background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
      padding: 60px 40px;
      position: relative;
      overflow: hidden;
    }
    
    .hero-banner::before {
      content: '';
      position: absolute;
      top: 0;
      right: -20%;
      width: 60%;
      height: 120%;
      background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
      transform: skewX(-20deg);
    }
    
    .hero-content {
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    
    .market-title {
      color: white;
      font-size: 36px;
      font-weight: 300;
      letter-spacing: -0.5px;
      margin-bottom: 20px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .date-time {
      color: rgba(255,255,255,0.9);
      font-size: 14px;
      font-weight: 400;
    }
    
    .main-content {
      max-width: 1200px;
      margin: 40px auto;
      padding: 0 40px;
    }
    
    .main-content h2 {
      color: #1a1a1a;
      font-size: 28px;
      font-weight: 600;
      margin: 40px 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #7c3aed;
    }
    
    .main-content h3 {
      color: #333;
      font-size: 22px;
      font-weight: 600;
      margin: 30px 0 15px 0;
    }
    
    .main-content h4 {
      color: #555;
      font-size: 18px;
      font-weight: 600;
      margin: 25px 0 15px 0;
    }
    
    .main-content p {
      color: #444;
      line-height: 1.8;
      margin-bottom: 16px;
      text-align: justify;
    }
    
    .main-content ul {
      margin: 16px 0;
      padding-left: 30px;
    }
    
    .main-content li {
      margin-bottom: 10px;
      line-height: 1.7;
    }
    
    .main-content a {
      color: #7c3aed;
      text-decoration: none;
      border-bottom: 1px solid transparent;
      transition: border-color 0.2s;
    }
    
    .main-content a:hover {
      border-bottom-color: #7c3aed;
    }
    
    .main-content div[style*="border: 2px solid"] {
      border-radius: 8px !important;
      margin: 24px 0 !important;
      padding: 20px !important;
      background: #f0f4ff !important;
      border-color: #7c3aed !important;
    }
    
    .main-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .main-content caption {
      background: #f8f9fa;
      padding: 16px;
      font-weight: 600;
      color: #333;
      text-align: left;
      border-bottom: 2px solid #7c3aed;
    }
    
    .main-content th {
      background: #7c3aed;
      color: white;
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .main-content td {
      padding: 14px 16px;
      border-bottom: 1px solid #eee;
    }
    
    .main-content tbody tr:hover {
      background: #f8f9fa;
    }
    
    .main-content tbody tr:last-child td {
      border-bottom: none;
    }
    
    .main-content tfoot {
      background: #f8f9fa;
      font-style: italic;
      font-size: 13px;
      color: #666;
    }
    
    .main-content .no-gradient {
      color: #7c3aed;
      font-weight: normal;
    }
    
    .footer {
      margin-top: 80px;
      padding: 30px 40px;
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
      text-align: center;
      color: #666;
      font-size: 13px;
    }
    
    .footer-logo {
      height: 30px;
      opacity: 0.6;
      margin-bottom: 10px;
    }
    
    @media print {
      .hero-banner {
        background: #7c3aed !important;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      .main-content {
        max-width: 100%;
      }
      
      .footer {
        display: none;
      }
    }
    
    @media (max-width: 768px) {
      .logo-container {
        flex-direction: column;
        gap: 10px;
      }
      
      .tagline {
        text-align: center;
        font-size: 11px;
      }
      
      .market-title {
        font-size: 24px;
      }
      
      .hero-banner {
        padding: 40px 20px;
      }
      
      .main-content {
        padding: 0 20px;
      }
      
      .main-content table {
        font-size: 14px;
      }
      
      .main-content th,
      .main-content td {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo-container">
      <img src="${config.url_logo}" alt="ChatInnov" class="logo">
      <div class="tagline">${config.presentation_text}</div>
    </div>
  </header>
  
  <div class="hero-banner">
    <div class="hero-content">
      <h1 class="market-title">${config.marketTitle}</h1>
      <div class="date-time">
        <strong>${t.report.generationDate} :</strong> ${dateStr} ${t.report.at} ${timeStr}
      </div>
    </div>
  </div>
  
  <main class="main-content">
    ${htmlContent}
  </main>
  
  <footer class="footer">
    <img src="${config.url_logo}" alt="ChatInnov" class="footer-logo">
    <p>${t.report.generatedBy}</p>
  </footer>
</body>
</html>`;
        
        return html;
      };

      // Fonction pour g√©n√©rer le Markdown
      const generateMarkdown = () => {
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US') + 
                       ' ' + t.report.at + ' ' + 
                       date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US');
        
        let md = `# ${config.marketTitle}\n\n`;
        md += `> ${config.presentation_text}\n\n`;
        md += `**${t.report.generationDate} :** ${dateStr}\n\n`;
        md += `---\n\n`;
        
        let content = config.content;
        
        if (content.includes('<')) {
          content = content.replace(/<table[^>]*>.*?<\/table>/gis, (match) => {
            return tableToMarkdown(match);
          });
          
          content = content
            .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n')
            .replace(/<h2[^>]*>.*?üî∑.*?<\/span>\s*(.*?)<\/h2>/gi, '## üî∑ $1\n\n')
            .replace(/<h3[^>]*>.*?üîπ.*?<\/span>\s*(.*?)<\/h3>/gi, '### üîπ $1\n\n')
            .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n\n')
            .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
            .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
            .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
            .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
            .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, (match, url, text) => {
              return `${text} (${url})`;
            })
            .replace(/<br[^>]*>/gi, '\n')
            .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n')
            .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n')
            .replace(/<ul[^>]*>|<\/ul>/gi, '')
            .replace(/<ol[^>]*>|<\/ol>/gi, '')
            .replace(/<span[^>]*class="no-gradient"[^>]*>(.*?)<\/span>/gi, '$1')
            .replace(/<div[^>]*style[^>]*>.*?<\/div>/gis, function(match) {
              const content = match.replace(/<[^>]+>/g, '');
              return `\n> ${content}\n\n`;
            })
            .replace(/<[^>]+>/g, '');
        } else {
          const lines = content.split('\n');
          let inTable = false;
          let tableData = [];
          let processedContent = [];
          
          lines.forEach((line, index) => {
            if (line.includes('\t') && !inTable) {
              inTable = true;
              tableData = [];
            }
            
            if (inTable) {
              if (line.includes('\t')) {
                tableData.push(line.split('\t').map(cell => cell.trim()));
              } else if (line.trim() === '' || !line.includes('\t')) {
                if (tableData.length > 0) {
                  processedContent.push('| ' + tableData[0].join(' | ') + ' |');
                  processedContent.push('| ' + tableData[0].map(() => '---').join(' | ') + ' |');
                  
                  for (let i = 1; i < tableData.length; i++) {
                    processedContent.push('| ' + tableData[i].join(' | ') + ' |');
                  }
                  processedContent.push('');
                }
                inTable = false;
                if (line.trim() !== '') {
                  processedContent.push(line);
                }
              }
            } else {
              line = line.trim();
              if (!line) {
                processedContent.push('');
              } else if (line.startsWith('üî∑')) {
                processedContent.push(`## ${line}\n`);
              } else if (line.startsWith('üîπ')) {
                processedContent.push(`### ${line}\n`);
              } else if (/^\d+\./.test(line) && line.length < 100) {
                processedContent.push(`#### ${line}\n`);
              } else if (line.startsWith('‚Ä¢') || line.startsWith('-')) {
                processedContent.push(`- ${line.substring(1).trim()}`);
              } else {
                line = line.replace(/([A-Za-z]+)\s*‚Äì\s*([^(]+)\s*\(([^)]+)\)/g, '$1 ‚Äì $2 ($3)');
                processedContent.push(line);
              }
            }
          });
          
          content = processedContent.join('\n');
        }
        
        md += content;
        md += `\n\n---\n\n*${t.report.generatedByShort}*`;
        
        return md;
      };

      // Fonction pour g√©n√©rer le PDF
      const generatePDF = async () => {
        if (!window.jspdf) {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          document.head.appendChild(script);
          await new Promise(resolve => script.onload = resolve);
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait'
        });
        
        doc.setFont('helvetica');
        
        let yPosition = 20;
        const pageHeight = doc.internal.pageSize.height;
        const pageWidth = doc.internal.pageSize.width;
        const margin = 20;
        const lineHeight = 7;
        const maxWidth = pageWidth - 2 * margin;
        
        doc.setFillColor(124, 58, 237);
        doc.rect(0, 0, pageWidth, 50, 'F');
        
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(18);
        const titleLines = doc.splitTextToSize(config.marketTitle, maxWidth);
        titleLines.forEach((line, index) => {
          doc.text(line, margin, 25 + (index * 8));
        });
        
        doc.setFontSize(10);
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US') + 
                       ' ' + t.report.at + ' ' + 
                       date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US');
        doc.text(dateStr, margin, 42);
        
        yPosition = 65;
        
        doc.setTextColor(124, 58, 237);
        doc.setFontSize(9);
        const taglineLines = doc.splitTextToSize(config.presentation_text, maxWidth);
        taglineLines.forEach(line => {
          doc.text(line, margin, yPosition);
          yPosition += 5;
        });
        
        yPosition += 10;
        
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(11);
        
        let textContent = config.content;
        
        if (textContent.includes('<')) {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = textContent;
          
          const extractText = (element, result = []) => {
            for (const node of element.childNodes) {
              if (node.nodeType === Node.TEXT_NODE) {
                const text = node.textContent.trim();
                if (text) result.push(text);
              } else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                
                if (tagName === 'h2') {
                  result.push('\n[H2] ' + node.textContent.trim() + '\n');
                } else if (tagName === 'h3') {
                  result.push('\n[H3] ' + node.textContent.trim() + '\n');
                } else if (tagName === 'h4') {
                  result.push('\n[H4] ' + node.textContent.trim() + '\n');
                } else if (tagName === 'p') {
                  const pContent = [];
                  for (const child of node.childNodes) {
                    if (child.nodeType === Node.TEXT_NODE) {
                      pContent.push(child.textContent);
                    } else if (child.tagName && child.tagName.toLowerCase() === 'a') {
                      const href = child.getAttribute('href');
                      const linkText = child.textContent;
                      pContent.push(`[LINK:${linkText}|${href}]`);
                    } else {
                      pContent.push(child.textContent || '');
                    }
                  }
                  result.push(pContent.join('') + '\n');
                } else if (tagName === 'li') {
                  const liContent = [];
                  for (const child of node.childNodes) {
                    if (child.nodeType === Node.TEXT_NODE) {
                      liContent.push(child.textContent);
                    } else if (child.tagName && child.tagName.toLowerCase() === 'a') {
                      const href = child.getAttribute('href');
                      const linkText = child.textContent;
                      liContent.push(`[LINK:${linkText}|${href}]`);
                    } else {
                      liContent.push(child.textContent || '');
                    }
                  }
                  result.push('‚Ä¢ ' + liContent.join('') + '\n');
                } else if (tagName === 'a') {
                  const href = node.getAttribute('href');
                  const linkText = node.textContent;
                  result.push(`[LINK:${linkText}|${href}]`);
                } else if (tagName === 'table') {
                  result.push('\n[TABLE_START]\n');
                  
                  const caption = node.querySelector('caption');
                  if (caption) {
                    result.push('[CAPTION] ' + caption.textContent.trim() + '\n');
                  }
                  
                  const headers = node.querySelectorAll('thead th, tbody tr:first-child th');
                  if (headers.length > 0) {
                    result.push('[HEADERS] ');
                    headers.forEach((header, index) => {
                      result.push(header.textContent.trim());
                      if (index < headers.length - 1) result.push(' | ');
                    });
                    result.push('\n');
                  }
                  
                  const rows = node.querySelectorAll('tbody tr');
                  rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length > 0) {
                      result.push('[ROW] ');
                      cells.forEach((cell, index) => {
                        result.push(cell.textContent.trim());
                        if (index < cells.length - 1) result.push(' | ');
                      });
                      result.push('\n');
                    }
                  });
                  
                  const footer = node.querySelector('tfoot');
                  if (footer) {
                    result.push('[FOOTER] ' + footer.textContent.trim() + '\n');
                  }
                  
                  result.push('[TABLE_END]\n\n');
                } else {
                  extractText(node, result);
                }
              }
            }
            return result;
          };
          
          const textArray = extractText(tempDiv);
          textContent = textArray.join('');
        } else if (!textContent.includes('[TABLE_START]')) {
          const lines = textContent.split('\n');
          let processedLines = [];
          let inTable = false;
          let tableBuffer = [];
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            if ((line.includes('\t') || line.includes('|')) && line.trim() !== '') {
              if (!inTable) {
                inTable = true;
                processedLines.push('[TABLE_START]');
                
                if (i > 0 && lines[i-1].trim() !== '' && !lines[i-1].includes('\t') && !lines[i-1].includes('|')) {
                  processedLines.push('[CAPTION] ' + lines[i-1].trim());
                }
              }
              
              const cells = line.split(/\t|\|/).map(cell => cell.trim()).filter(cell => cell);
              if (cells.length > 0) {
                if (tableBuffer.length === 0) {
                  processedLines.push('[HEADERS] ' + cells.join(' | '));
                } else {
                  processedLines.push('[ROW] ' + cells.join(' | '));
                }
                tableBuffer.push(cells);
              }
            } else if (inTable) {
              if (line.includes('Source:')) {
                processedLines.push('[FOOTER] ' + line.trim());
              }
              processedLines.push('[TABLE_END]');
              inTable = false;
              tableBuffer = [];
              
              if (line.trim() !== '' && !line.includes('Source:')) {
                processedLines.push(line);
              }
            } else {
              processedLines.push(line);
            }
          }
          
          if (inTable) {
            processedLines.push('[TABLE_END]');
          }
          
          textContent = processedLines.join('\n');
        }
        
        textContent = textContent
          .replace(/[^\x00-\x7F\u00A0-\u00FF\u0100-\u017F\u0180-\u024F\[\]:|]/g, '')
          .replace(/üî∑/g, '[>]')
          .replace(/üîπ/g, '[‚Ä¢]')
          .replace(/‚Ä¢/g, '‚Ä¢')
          .replace(/‚Äì/g, '-')
          .replace(/‚Äî/g, '--');
        
        const addLink = (text, url, x, y) => {
          doc.setTextColor(124, 58, 237);
          doc.textWithLink(text, x, y, { url: url });
          doc.setTextColor(0, 0, 0);
        };
        
        const lines = textContent.split('\n');
        let inTable = false;
        let tableData = {
          caption: '',
          headers: [],
          rows: [],
          footer: ''
        };
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          if (line === '[TABLE_START]') {
            inTable = true;
            tableData = { caption: '', headers: [], rows: [], footer: '' };
            continue;
          } else if (line === '[TABLE_END]') {
            inTable = false;
            
            if (tableData.headers.length > 0 || tableData.rows.length > 0) {
              yPosition += 5;
              
              if (tableData.caption) {
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                const captionLines = doc.splitTextToSize(tableData.caption, maxWidth);
                captionLines.forEach(captionLine => {
                  if (yPosition > pageHeight - margin) {
                    doc.addPage();
                    yPosition = margin;
                  }
                  doc.text(captionLine, margin, yPosition);
                  yPosition += lineHeight;
                });
                doc.setFont(undefined, 'normal');
                doc.setFontSize(11);
                yPosition += 2;
              }
              
              const numCols = Math.max(tableData.headers.length, 
                ...tableData.rows.map(row => row.length));
              const colWidth = maxWidth / numCols;
              
              if (tableData.headers.length > 0) {
                doc.setFillColor(237, 233, 254);
                doc.rect(margin, yPosition - 5, maxWidth, 8, 'F');
                doc.setFont(undefined, 'bold');
                doc.setFontSize(9);
                
                tableData.headers.forEach((header, index) => {
                  const headerText = header.substring(0, Math.floor(colWidth / 2));
                  doc.text(headerText, margin + (index * colWidth) + 2, yPosition);
                });
                
                yPosition += 8;
                doc.setFont(undefined, 'normal');
              }
              
              doc.setFontSize(9);
              tableData.rows.forEach((row, rowIndex) => {
                if (yPosition > pageHeight - margin - 10) {
                  doc.addPage();
                  yPosition = margin;
                }
                
                if (rowIndex % 2 === 1) {
                  doc.setFillColor(248, 249, 250);
                  doc.rect(margin, yPosition - 4, maxWidth, 6, 'F');
                }
                
                row.forEach((cell, index) => {
                  const cellText = cell.substring(0, Math.floor(colWidth / 2));
                  doc.text(cellText, margin + (index * colWidth) + 2, yPosition);
                });
                
                yPosition += 6;
              });
              
              if (tableData.footer) {
                doc.setFontSize(8);
                doc.setFont(undefined, 'italic');
                doc.setTextColor(100);
                const footerLines = doc.splitTextToSize(tableData.footer, maxWidth);
                footerLines.forEach(footerLine => {
                  if (yPosition > pageHeight - margin) {
                    doc.addPage();
                    yPosition = margin;
                  }
                  doc.text(footerLine, margin, yPosition);
                  yPosition += 5;
                });
                doc.setTextColor(0);
                doc.setFont(undefined, 'normal');
                doc.setFontSize(11);
              }
              
              yPosition += 5;
            }
            continue;
          }
          
          if (inTable) {
            if (line.startsWith('[CAPTION]')) {
              tableData.caption = line.replace('[CAPTION]', '').trim();
            } else if (line.startsWith('[HEADERS]')) {
              tableData.headers = line.replace('[HEADERS]', '').trim().split('|').map(h => h.trim());
            } else if (line.startsWith('[ROW]')) {
              tableData.rows.push(line.replace('[ROW]', '').trim().split('|').map(c => c.trim()));
            } else if (line.startsWith('[FOOTER]')) {
              tableData.footer = line.replace('[FOOTER]', '').trim();
            }
          } else if (line) {
            if (line.startsWith('[H2]')) {
              doc.setFontSize(14);
              doc.setFont(undefined, 'bold');
              const text = line.replace('[H2]', '').trim();
              const textLines = doc.splitTextToSize(text, maxWidth);
              textLines.forEach(textLine => {
                if (yPosition > pageHeight - margin) {
                  doc.addPage();
                  yPosition = margin;
                }
                doc.text(textLine, margin, yPosition);
                yPosition += lineHeight + 2;
              });
              doc.setFont(undefined, 'normal');
              doc.setFontSize(11);
              yPosition += 3;
            } else if (line.startsWith('[H3]')) {
              doc.setFontSize(12);
              doc.setFont(undefined, 'bold');
              const text = line.replace('[H3]', '').trim();
              const textLines = doc.splitTextToSize(text, maxWidth);
              textLines.forEach(textLine => {
                if (yPosition > pageHeight - margin) {
                  doc.addPage();
                  yPosition = margin;
                }
                doc.text(textLine, margin, yPosition);
                yPosition += lineHeight + 1;
              });
              doc.setFont(undefined, 'normal');
              doc.setFontSize(11);
              yPosition += 2;
            } else if (line.startsWith('[H4]')) {
              doc.setFont(undefined, 'bold');
              const text = line.replace('[H4]', '').trim();
              const textLines = doc.splitTextToSize(text, maxWidth);
              textLines.forEach(textLine => {
                if (yPosition > pageHeight - margin) {
                  doc.addPage();
                  yPosition = margin;
                }
                doc.text(textLine, margin, yPosition);
                yPosition += lineHeight;
              });
              doc.setFont(undefined, 'normal');
              yPosition += 2;
            } else {
              let currentX = margin;
              
              const linkRegex = /\[LINK:([^|]+)\|([^\]]+)\]/g;
              let lastIndex = 0;
              let match;
              
              while ((match = linkRegex.exec(line)) !== null) {
                const beforeText = line.substring(lastIndex, match.index);
                if (beforeText) {
                  const beforeLines = doc.splitTextToSize(beforeText, maxWidth - (currentX - margin));
                  beforeLines.forEach((textLine, index) => {
                    if (yPosition > pageHeight - margin) {
                      doc.addPage();
                      yPosition = margin;
                      currentX = margin;
                    }
                    doc.text(textLine, currentX, yPosition);
                    if (index < beforeLines.length - 1) {
                      yPosition += lineHeight;
                      currentX = margin;
                    } else {
                      currentX += doc.getTextWidth(textLine);
                    }
                  });
                }
                
                const linkText = match[1];
                const linkUrl = match[2];
                
                if (yPosition > pageHeight - margin) {
                  doc.addPage();
                  yPosition = margin;
                  currentX = margin;
                }
                
                addLink(linkText, linkUrl, currentX, yPosition);
                currentX += doc.getTextWidth(linkText);
                
                lastIndex = match.index + match[0].length;
              }
              
              const afterText = line.substring(lastIndex);
              if (afterText) {
                const afterLines = doc.splitTextToSize(afterText, maxWidth - (currentX - margin));
                afterLines.forEach((textLine, index) => {
                  if (yPosition > pageHeight - margin) {
                    doc.addPage();
                    yPosition = margin;
                    currentX = margin;
                  }
                  doc.text(textLine, currentX, yPosition);
                  if (index < afterLines.length - 1 || index === afterLines.length - 1) {
                    yPosition += lineHeight;
                    currentX = margin;
                  }
                });
              } else if (line.includes('[LINK:')) {
                yPosition += lineHeight;
              }
              
              if (!line.includes('[LINK:')) {
                const textLines = doc.splitTextToSize(line, maxWidth);
                textLines.forEach(textLine => {
                  if (yPosition > pageHeight - margin) {
                    doc.addPage();
                    yPosition = margin;
                  }
                  doc.text(textLine, margin, yPosition);
                  yPosition += lineHeight;
                });
              }
            }
          }
        }
        
        doc.setFontSize(9);
        doc.setTextColor(150);
        doc.text(t.report.generatedBy, pageWidth / 2, pageHeight - 10, { align: 'center' });
        
        return doc;
      };

      // BOUTON COPIER
      if (config.showCopyButton) {
        const copyWrapper = document.createElement('div');
        copyWrapper.className = 'action-button-wrapper';

        const copyButton = document.createElement('button');
        copyButton.className = 'action-button';
        copyButton.innerHTML = `<span class="action-button-icon">${config.copyIconText}</span>`;
        copyButton.title = t.copy.buttonTitle;

        const copyMenu = document.createElement('div');
        copyMenu.className = 'action-menu';
        
        const htmlOption = document.createElement('button');
        htmlOption.className = 'action-menu-option';
        htmlOption.innerHTML = `
          <span class="action-menu-option-icon">üé®</span>
          <span>${t.copy.formatOption}</span>
        `;
        htmlOption.title = t.copy.formatTooltip;
        
        const textOption = document.createElement('button');
        textOption.className = 'action-menu-option';
        textOption.innerHTML = `
          <span class="action-menu-option-icon">üìù</span>
          <span>${t.copy.rawOption}</span>
        `;
        textOption.title = t.copy.rawTooltip;
        
        copyMenu.appendChild(htmlOption);
        copyMenu.appendChild(textOption);

        // CORRECTION : Copie format√©e utilise l'API Clipboard moderne
        const copyContent = async (format = 'html') => {
          try {
            if (format === 'html') {
              // Pour une vraie copie format√©e, on utilise l'API Clipboard write
              if (navigator.clipboard && navigator.clipboard.write) {
                // Cr√©er un √©l√©ment temporaire pour avoir le rendu visuel
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = config.content;
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                document.body.appendChild(tempDiv);
                
                // S√©lectionner et copier avec formatage
                const range = document.createRange();
                range.selectNodeContents(tempDiv);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                document.execCommand('copy');
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                
                showToast(t.copy.toastFormatted);
              } else {
                // Fallback : copier le HTML brut
                await navigator.clipboard.writeText(config.content);
                showToast(t.copy.toastFormatted + ' (HTML)');
              }
            } else {
              // Copie en texte brut
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = config.content;
              const textContent = tempDiv.textContent || tempDiv.innerText || '';
              await navigator.clipboard.writeText(textContent);
              showToast(t.copy.toastRaw);
            }
            
            // Feedback visuel
            copyButton.classList.add('copied');
            copyButton.querySelector('.action-button-icon').textContent = config.copiedIcon;
            
            console.log(`‚úÖ Contenu copi√© (${format})`);
            
            setTimeout(() => {
              copyButton.classList.remove('copied');
              copyButton.querySelector('.action-button-icon').textContent = config.copyIconText;
            }, 2000);
            
          } catch (err) {
            console.error('Erreur de copie:', err);
            showToast(t.copy.toastError);
          }
        };

        copyButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!copyMenuVisible) {
            copyMenu.classList.add('show');
            copyMenuVisible = true;
            const downloadMenu = container.querySelector('.download-menu');
            if (downloadMenu) downloadMenu.classList.remove('show');
            downloadMenuVisible = false;
          } else {
            copyMenu.classList.remove('show');
            copyMenuVisible = false;
          }
        });

        htmlOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          copyContent('html');
          copyMenu.classList.remove('show');
          copyMenuVisible = false;
        });

        textOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          copyContent('text');
          copyMenu.classList.remove('show');
          copyMenuVisible = false;
        });

        copyWrapper.appendChild(copyButton);
        copyWrapper.appendChild(copyMenu);
        container.appendChild(copyWrapper);
      }

      // BOUTON T√âL√âCHARGER
      if (config.showDownloadButton) {
        const downloadWrapper = document.createElement('div');
        downloadWrapper.className = 'action-button-wrapper';

        const downloadButton = document.createElement('button');
        downloadButton.className = 'action-button';
        downloadButton.innerHTML = `<span class="action-button-icon">${config.downloadIconText}</span>`;
        downloadButton.title = t.download.buttonTitle;

        const downloadMenu = document.createElement('div');
        downloadMenu.className = 'action-menu download-menu';

        const formatIcons = {
          html: 'üåê',
          pdf: 'üìÑ',
          md: 'üìù'
        };

        const formatLabels = {
          html: 'HTML',
          pdf: 'PDF',
          md: 'Markdown'
        };

        config.formats.forEach(format => {
          const option = document.createElement('button');
          option.className = 'action-menu-option';
          option.innerHTML = `
            <span class="action-menu-option-icon">${formatIcons[format]}</span>
            <span>${formatLabels[format]}</span>
          `;
          option.addEventListener('click', () => downloadReport(format));
          downloadMenu.appendChild(option);
        });

        const downloadReport = async (format) => {
          downloadButton.classList.add('generating');
          downloadButton.querySelector('.action-button-icon').textContent = '‚è≥';
          downloadMenu.classList.remove('show');
          
          try {
            const date = new Date().toISOString().slice(0, 10);
            const fileName = `${config.fileName}_${date}`;
            
            switch(format) {
              case 'html':
                const htmlContent = generateHTML();
                const htmlBlob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const htmlUrl = URL.createObjectURL(htmlBlob);
                window.open(htmlUrl, '_blank');
                setTimeout(() => {
                  URL.revokeObjectURL(htmlUrl);
                }, 1000);
                break;
                
              case 'md':
                const mdContent = generateMarkdown();
                const mdBlob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8' });
                const mdUrl = URL.createObjectURL(mdBlob);
                const mdLink = document.createElement('a');
                mdLink.href = mdUrl;
                mdLink.download = `${fileName}.md`;
                mdLink.click();
                URL.revokeObjectURL(mdUrl);
                break;
                
              case 'pdf':
                const pdf = await generatePDF();
                pdf.save(`${fileName}.pdf`);
                break;
            }
            
            let successMessage = '';
            switch(format) {
              case 'html':
                successMessage = t.download.toastHTML;
                break;
              case 'pdf':
                successMessage = t.download.toastPDF;
                break;
              case 'md':
                successMessage = t.download.toastMarkdown;
                break;
            }
            
            showToast(successMessage);
            
            console.log(`‚úÖ Rapport ${format.toUpperCase()} g√©n√©r√© : ${fileName}`);
            
          } catch (error) {
            console.error('‚ùå Erreur de g√©n√©ration:', error);
            showToast(t.download.toastError);
          } finally {
            downloadButton.classList.remove('generating');
            downloadButton.querySelector('.action-button-icon').textContent = config.downloadIconText;
          }
        };

        downloadButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!downloadMenuVisible) {
            downloadMenu.classList.add('show');
            downloadMenuVisible = true;
            const copyMenu = container.querySelector('.action-menu:not(.download-menu)');
            if (copyMenu) copyMenu.classList.remove('show');
            copyMenuVisible = false;
          } else {
            downloadMenu.classList.remove('show');
            downloadMenuVisible = false;
          }
        });

        downloadWrapper.appendChild(downloadButton);
        downloadWrapper.appendChild(downloadMenu);
        container.appendChild(downloadWrapper);
      }

      // √âv√©nement global pour fermer les menus
      document.addEventListener('click', (e) => {
        if (!container.contains(e.target)) {
          container.querySelectorAll('.action-menu').forEach(menu => {
            menu.classList.remove('show');
          });
          copyMenuVisible = false;
          downloadMenuVisible = false;
        }
      });

      element.appendChild(container);
      
      setTimeout(() => {
        const parentMessage = element.closest('.vfrc-message');
        if (parentMessage) {
          parentMessage.style.background = 'transparent';
          parentMessage.style.padding = '0';
          parentMessage.style.margin = '0';
          parentMessage.style.border = 'none';
          parentMessage.style.boxShadow = 'none';
        }
      }, 0);
      
      console.log('‚úÖ DownloadReport multilingue pr√™t');
      
    } catch (error) {
      console.error('‚ùå DownloadReport Error:', error);
    }
  }
};

export default DownloadReport;
