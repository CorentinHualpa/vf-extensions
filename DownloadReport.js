/**
 *  ╔═══════════════════════════════════════════════════════════╗
 *  ║  DownloadReport – ChatInnov Edition Multilingue           ║
 *  ║                                                           ║
 *  ║  • Support JSON et TEXT                                   ║
 *  ║  • Téléchargement : HTML / PDF / Markdown / DOCX         ║
 *  ║  • Copie : Brut (HTML) / Formaté (texte propre)         ║
 *  ║  • Support FR/EN                                         ║
 *  ╚═══════════════════════════════════════════════════════════╝
 */

export const DownloadReport = {
  name: 'DownloadReport',
  type: 'response',
  
  match: ({ trace }) => trace.type === 'download_report' || trace.payload?.type === 'download_report',

  render: ({ trace, element }) => {
    try {
      // Traductions
      const translations = {
        fr: {
          copy: {
            buttonTitle: 'Copier texte',
            formatOption: 'Formaté',
            formatTooltip: 'Copier le texte formaté (sans HTML)',
            rawOption: 'Brut',
            rawTooltip: 'Copier le code HTML brut',
            toastFormatted: 'Texte formaté copié',
            toastRaw: 'HTML brut copié',
            toastError: 'Erreur lors de la copie'
          },
          download: {
            buttonTitle: 'Télécharger le rapport',
            toastHTML: 'Rapport ouvert dans un nouvel onglet',
            toastPDF: 'PDF téléchargé avec succès',
            toastMarkdown: 'Markdown téléchargé avec succès',
            toastDOCX: 'Document Word téléchargé avec succès',
            toastError: 'Erreur lors de la génération'
          },
          report: {
            generationDate: 'Date de génération',
            at: 'à',
            generatedBy: '© ChatInnov - Rapport généré automatiquement',
            generatedByShort: 'Rapport généré par ChatInnov'
          }
        },
        en: {
          copy: {
            buttonTitle: 'Copy text',
            formatOption: 'Formatted',
            formatTooltip: 'Copy formatted text (without HTML)',
            rawOption: 'Raw',
            rawTooltip: 'Copy raw HTML code',
            toastFormatted: 'Formatted text copied',
            toastRaw: 'Raw HTML copied',
            toastError: 'Copy error'
          },
          download: {
            buttonTitle: 'Download report',
            toastHTML: 'Report opened in new tab',
            toastPDF: 'PDF downloaded successfully',
            toastMarkdown: 'Markdown downloaded successfully',
            toastDOCX: 'Word document downloaded successfully',
            toastError: 'Generation error'
          },
          report: {
            generationDate: 'Generation date',
            at: 'at',
            generatedBy: '© ChatInnov - Automatically generated report',
            generatedByShort: 'Report generated by ChatInnov'
          }
        }
      };

      // Configuration par défaut
      const defaultConfig = {
        marketTitle: 'Analyse de Marché',
        content: '',
        fileName: 'chatinnov_rapport',
        url_logo: 'https://i.imgur.com/qWcV9Z9.png',
        presentation_text: "L'IA GENERATIVE AU SERVICE DE L'INTELLIGENCE DES MARCHÉS ET DE L'INNOVATION À IMPACT",
        accentColor: '#666666',
        downloadIconText: '📥',
        copyIconText: '📋',
        copiedIcon: '✅',
        formats: ['html', 'pdf', 'md', 'docx'],
        showCopyButton: true,
        showDownloadButton: true,
        langue: 'fr'
      };

      // Parser le payload
      let config = { ...defaultConfig };
      
      if (typeof trace.payload === 'string') {
        try {
          let cleanPayload = trace.payload.trim();
          
          // Si c'est du JSON (commence par {)
          if (cleanPayload.startsWith('{')) {
            try {
              const parsed = JSON.parse(cleanPayload);
              config = { ...defaultConfig, ...parsed };
            } catch (e) {
              console.log('Tentative de nettoyage du JSON...');
              
              // Parsing manuel en cas d'échec
              const marketTitleMatch = cleanPayload.match(/"marketTitle"\s*:\s*"([^"]+)"/);
              const fileNameMatch = cleanPayload.match(/"fileName"\s*:\s*"([^"]+)"/);
              const urlLogoMatch = cleanPayload.match(/"url_logo"\s*:\s*"([^"]+)"/);
              const presentationMatch = cleanPayload.match(/"presentation_text"\s*:\s*"([^"]+)"/);
              const contentMatch = cleanPayload.match(/"content"\s*:\s*"([\s\S]*?)"\s*,\s*"[^"]+"\s*:/);
              const langueMatch = cleanPayload.match(/"langue"\s*:\s*"([^"]+)"/);
              
              if (marketTitleMatch) config.marketTitle = marketTitleMatch[1];
              if (fileNameMatch) config.fileName = fileNameMatch[1];
              if (urlLogoMatch) config.url_logo = urlLogoMatch[1];
              if (presentationMatch) config.presentation_text = presentationMatch[1];
              if (langueMatch) config.langue = langueMatch[1];
              if (contentMatch) {
                config.content = contentMatch[1]
                  .replace(/\\n/g, '\n')
                  .replace(/\\"/g, '"')
                  .replace(/\\/g, '');
              }
            }
          } else {
            // MODE TEXT avec options
            const parts = cleanPayload.split('###OPTIONS###');
            
            // Le contenu est la première partie
            config.content = parts[0].trim();
            
            // IMPORTANT : S'assurer que la partie OPTIONS n'apparaît pas dans le contenu
            if (config.content.includes('###OPTIONS###')) {
              config.content = config.content.split('###OPTIONS###')[0].trim();
            }
            
            // Parser les options si présentes
            if (parts[1]) {
              const optionsText = parts[1].trim();
              const lines = optionsText.split('\n');
              
              lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine && trimmedLine.includes('=')) {
                  const [key, ...valueParts] = trimmedLine.split('=');
                  const value = valueParts.join('=').trim();
                  const cleanKey = key.trim();
                  
                  // Conversion des types
                  if (value === 'true') {
                    config[cleanKey] = true;
                  } else if (value === 'false') {
                    config[cleanKey] = false;
                  } else if (cleanKey === 'formats' && value.includes(',')) {
                    config[cleanKey] = value.split(',').map(f => f.trim());
                  } else {
                    config[cleanKey] = value;
                  }
                }
              });
            }
          }
        } catch (error) {
          console.error('Erreur de parsing:', error);
          config.content = trace.payload;
        }
      } else if (typeof trace.payload === 'object' && trace.payload !== null) {
        config = { ...defaultConfig, ...trace.payload };
      }

      // Fonction pour nettoyer les caractères mal encodés
      const cleanContent = (text) => {
        return text
          // Remplacer les caractères mal encodés
          .replace(/ðŸ"·/g, '🔷')
          .replace(/ðŸ"¹/g, '🔹')
          .replace(/â€™/g, "'")
          .replace(/â€"/g, "–")
          .replace(/â€œ/g, '"')
          .replace(/â€/g, '"')
          .replace(/â€¦/g, '...')
          .replace(/â€¢/g, '•')
          .replace(/â€"/g, '—')
          .replace(/Ã©/g, 'é')
          .replace(/Ã¨/g, 'è')
          .replace(/Ã /g, 'à')
          .replace(/Ã§/g, 'ç')
          .replace(/Ã¢/g, 'â')
          .replace(/Ãª/g, 'ê')
          .replace(/Ã®/g, 'î')
          .replace(/Ã´/g, 'ô')
          .replace(/Ã»/g, 'û')
          .replace(/Ã‰/g, 'É')
          .replace(/Ãˆ/g, 'È')
          .replace(/Ã€/g, 'À')
          .replace(/Ã‡/g, 'Ç')
          .replace(/Ã‚/g, 'Â')
          .replace(/ÃŠ/g, 'Ê')
          .replace(/ÃŽ/g, 'Î')
          .replace(/Ã"/g, 'Ô')
          .replace(/Ã›/g, 'Û');
      };

      // Nettoyer le contenu
      config.content = cleanContent(config.content);

      // Vérifier si on a du contenu
      if (!config.content || config.content.trim() === '') {
        console.warn('DownloadReport: Aucun contenu fourni');
        return;
      }

      // Vérifier si au moins un bouton doit être affiché
      if (!config.showCopyButton && !config.showDownloadButton) {
        console.warn('DownloadReport: Aucun bouton à afficher');
        return;
      }

      // Sélectionner la bonne langue
      const lang = config.langue === 'en' ? 'en' : 'fr';
      const t = translations[lang];

      // Container principal pour les boutons
      const container = document.createElement('div');
      container.className = 'report-actions-container';
      
      // Styles minimalistes unifiés
      const styleEl = document.createElement('style');
      styleEl.textContent = `
        /* Container principal pour les actions */
        .report-actions-container {
          display: inline-flex !important;
          gap: 8px !important;
          align-items: center !important;
          margin: -0.75rem 0 0.5rem 0 !important;
          justify-content: flex-end !important;
          width: 100% !important;
        }

        /* Wrapper commun pour les boutons */
        .action-button-wrapper {
          position: relative !important;
          display: inline-flex !important;
          align-items: center !important;
        }

        /* Style commun pour tous les boutons */
        .action-button {
          background: transparent !important;
          color: ${config.accentColor} !important;
          border: 1px solid transparent !important;
          padding: 4px 8px !important;
          border-radius: 6px !important;
          font-size: 16px !important;
          cursor: pointer !important;
          display: inline-flex !important;
          align-items: center !important;
          justify-content: center !important;
          transition: all 0.2s ease !important;
          min-width: 32px !important;
          height: 32px !important;
        }

        .action-button:hover {
          background: rgba(0, 0, 0, 0.05) !important;
          border-color: rgba(0, 0, 0, 0.1) !important;
        }

        /* État copié */
        .action-button.copied {
          color: #4CAF50 !important;
        }

        /* Icône des boutons */
        .action-button-icon {
          font-size: 16px !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: all 0.2s ease !important;
        }

        .action-button:hover .action-button-icon {
          opacity: 1 !important;
        }

        /* Menu déroulant commun */
        .action-menu {
          position: absolute !important;
          bottom: calc(100% + 2px) !important;
          right: 0 !important;
          background: white !important;
          border: 1px solid #e0e0e0 !important;
          border-radius: 6px !important;
          box-shadow: 0 -2px 8px rgba(0,0,0,0.1) !important;
          padding: 2px !important;
          z-index: 1000 !important;
          opacity: 0 !important;
          visibility: hidden !important;
          transition: all 0.15s ease !important;
          min-width: auto !important;
        }

        /* Si le menu risque de sortir en haut de l'écran, le placer en bas */
        .action-menu.menu-below {
          bottom: auto !important;
          top: calc(100% + 2px) !important;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }

        .action-menu.show {
          opacity: 1 !important;
          visibility: visible !important;
        }

        /* Options du menu */
        .action-menu-option {
          display: flex !important;
          align-items: center !important;
          gap: 6px !important;
          padding: 6px 12px !important;
          border: none !important;
          background: none !important;
          color: #333 !important;
          font-size: 12px !important;
          cursor: pointer !important;
          border-radius: 4px !important;
          transition: all 0.1s ease !important;
          width: 100% !important;
          text-align: left !important;
          white-space: nowrap !important;
        }

        .action-menu-option:hover {
          background: #f0f0f0 !important;
        }

        .action-menu-option-icon {
          opacity: 0.8 !important;
          font-size: 14px !important;
        }

        /* Séparateur dans les menus */
        .action-menu-option + .action-menu-option {
          border-top: 1px solid #f0f0f0 !important;
        }

        /* État de génération */
        .action-button.generating {
          opacity: 0.6 !important;
          cursor: wait !important;
        }

        .action-button.generating .action-button-icon {
          animation: spin 1s linear infinite !important;
        }

        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }

        /* Toast de notification unifié */
        .action-toast {
          position: fixed !important;
          bottom: 20px !important;
          right: 20px !important;
          background: rgba(0,0,0,0.8) !important;
          color: white !important;
          padding: 8px 16px !important;
          border-radius: 6px !important;
          font-size: 13px !important;
          box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
          z-index: 10000 !important;
          opacity: 0 !important;
          transform: translateY(10px) !important;
          transition: all 0.2s ease !important;
          pointer-events: none !important;
        }

        .action-toast.show {
          opacity: 1 !important;
          transform: translateY(0) !important;
        }

        /* Masquer le background gris du message Voiceflow */
        .vfrc-message--extension-DownloadReport {
          background: transparent !important;
          padding: 0 !important;
          margin: 0 !important;
          border: none !important;
          box-shadow: none !important;
        }

        /* Animation d'entrée */
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }

        .action-button {
          animation: fadeIn 0.3s ease-out !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
          .action-button {
            padding: 6px !important;
            min-width: 28px !important;
            height: 28px !important;
          }
          
          .action-button-icon {
            font-size: 14px !important;
          }
        }
      `;

      container.appendChild(styleEl);

      // Toast de notification partagé
      let toast = document.querySelector('.action-toast');
      if (!toast) {
        toast = document.createElement('div');
        toast.className = 'action-toast';
        document.body.appendChild(toast);
      }

      // Fonction pour afficher le toast
      const showToast = (message) => {
        toast.textContent = message;
        toast.classList.add('show');
        
        setTimeout(() => {
          toast.classList.remove('show');
        }, 1500);
      };

      // Variables pour gérer l'état des menus
      let copyMenuVisible = false;
      let downloadMenuVisible = false;

      // Fonction pour charger une image en base64
      const loadImageAsBase64 = async (url) => {
        try {
          const response = await fetch(url);
          const blob = await response.blob();
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.error('Erreur de chargement de l\'image:', error);
          return null;
        }
      };

      // Fonction pour extraire les images du HTML
      const extractImagesFromHTML = (html) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const images = [];
        const imgElements = tempDiv.querySelectorAll('img');
        
        imgElements.forEach((img, index) => {
          images.push({
            src: img.src,
            alt: img.alt || `Image ${index + 1}`,
            width: img.width || 200,
            height: img.height || 150
          });
        });
        
        return images;
      };

      // Fonction pour convertir un tableau HTML en Markdown
      const tableToMarkdown = (tableHtml) => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = tableHtml;
        const table = tempDiv.querySelector('table');
        
        if (!table) return tableHtml;
        
        let markdown = '\n\n';
        
        const caption = table.querySelector('caption');
        if (caption) {
          markdown += `**${caption.textContent.trim()}**\n\n`;
        }
        
        const headers = Array.from(table.querySelectorAll('thead th, tbody tr:first-child th')).map(th => th.textContent.trim());
        if (headers.length === 0) {
          const firstRow = table.querySelector('tr');
          if (firstRow) {
            headers.push(...Array.from(firstRow.querySelectorAll('td, th')).map(cell => cell.textContent.trim()));
          }
        }
        
        if (headers.length > 0) {
          markdown += '| ' + headers.join(' | ') + ' |\n';
          markdown += '| ' + headers.map(() => '---').join(' | ') + ' |\n';
        }
        
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
          const cells = Array.from(row.querySelectorAll('td'));
          if (cells.length > 0) {
            markdown += '| ' + cells.map(cell => cell.textContent.trim()).join(' | ') + ' |\n';
          }
        });
        
        const footer = table.querySelector('tfoot');
        if (footer) {
          markdown += `\n*${footer.textContent.trim()}*\n`;
        }
        
        return markdown + '\n';
      };

      // Fonction pour générer le HTML
// Fonction pour générer le HTML
// Fonction pour générer le HTML
// Fonction pour générer le HTML
const generateHTML = () => {
  const date = new Date();
  const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US', {
    day: '2-digit',
    month: 'long',
    year: 'numeric'
  });
  const timeStr = date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US', {
    hour: '2-digit',
    minute: '2-digit'
  });
  
  let htmlContent = config.content;
  
  if (!htmlContent.includes('<')) {
    htmlContent = htmlContent
      .split('\n')
      .map(line => {
        line = line.trim();
        if (!line) return '';
        
        if (line.startsWith('🔷')) {
          return `<h2><span class="no-gradient">🔷</span> ${line.substring(2).trim()}</h2>`;
        }
        if (line.startsWith('🔹')) {
          return `<h3><span class="no-gradient">🔹</span> ${line.substring(2).trim()}</h3>`;
        }
        
        if (/^\d+\./.test(line) && line.length < 100) {
          return `<h4>${line}</h4>`;
        }
        
        if (line.startsWith('•') || line.startsWith('-')) {
          return `<li>${line.substring(1).trim()}</li>`;
        }
        
        line = line.replace(/([A-Za-z]+)\s*–\s*([^(]+)\s*\(([^)]+)\)/g, 
          '<a href="$3" target="_blank">$1 – $2</a>');
        
        return `<p>${line}</p>`;
      })
      .join('\n')
      .replace(/<li>/g, '<ul><li>')
      .replace(/<\/li>\n(?!<li>)/g, '</li></ul>\n');
  }
  
  // Convertir les divs avec bordures en tableaux pour Word
  htmlContent = htmlContent.replace(
    /<div style="border: 2px solid[^>]+>([\s\S]*?)<\/div>/gi,
    function(match, content) {
      return `
        <table style="width: 100%; margin: 20px 0; border: none;">
          <tr>
            <td style="background: #f0f4ff; padding: 20px; border: 2px solid #7c3aed; border-radius: 8px;">
              ${content}
            </td>
          </tr>
        </table>
      `;
    }
  );
  
  const html = `<!DOCTYPE html>
<html lang="${lang}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="ProgId" content="Word.Document">
  <title>${config.marketTitle} - ChatInnov</title>
  <style>
    /* Base styles avec fond blanc */
    html, body {
      background: white;
      background-color: white;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      line-height: 1.6;
      color: #333;
      margin: 20px;
      padding: 0;
    }
    
    /* Forcer le fond blanc sur les éléments de structure */
    .page-header, .main-content, .page-footer {
      background: white;
    }
    
    .page-header {
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 2px solid #7c3aed;
    }
    
    .header-table {
      width: 100%;
      border: none;
      background: white;
    }
    
    .header-table td {
      border: none;
      padding: 5px;
      vertical-align: middle;
      background: white;
    }
    
    .logo-cell {
      width: 120px;
      text-align: left;
    }
    
    .title-cell {
      text-align: center;
      padding: 0 20px;
    }
    
    .tagline-cell {
      width: 200px;
      text-align: right;
    }
    
    h1 {
      color: #1a1a1a;
      font-size: 22px;
      font-weight: bold;
      margin: 5px 0;
    }
    
    .date-info {
      color: #666;
      font-size: 12px;
      margin-top: 5px;
    }
    
    .tagline-text {
      color: #7c3aed;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
      line-height: 1.2;
    }
    
    .main-content h2 {
      color: #1a1a1a;
      font-size: 20px;
      font-weight: bold;
      margin: 25px 0 15px 0;
      padding-bottom: 5px;
      border-bottom: 1px solid #7c3aed;
    }
    
    .main-content h3 {
      color: #333;
      font-size: 18px;
      font-weight: bold;
      margin: 20px 0 10px 0;
    }
    
    .main-content h4 {
      color: #555;
      font-size: 16px;
      font-weight: bold;
      margin: 15px 0 10px 0;
    }
    
    .main-content p {
      margin-bottom: 12px;
      text-align: justify;
      color: #333;
    }
    
    .main-content ul {
      margin: 10px 0;
      padding-left: 25px;
    }
    
    .main-content li {
      margin-bottom: 5px;
      color: #333;
    }
    
    .main-content a {
      color: #7c3aed;
      text-decoration: none;
    }
    
    /* Styles des tableaux - conservés pour la beauté */
    .main-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .main-content caption {
      background: #f8f9fa;
      padding: 16px;
      font-weight: bold;
      color: #333;
      text-align: center;
      border-bottom: 2px solid #7c3aed;
      font-size: 14px;
    }
    
    .main-content th {
      background: #7c3aed;
      color: white;
      padding: 12px;
      text-align: left;
      font-weight: bold;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .main-content td {
      padding: 12px;
      border-bottom: 1px solid #eee;
      color: #333;
      background: white;
    }
    
    .main-content tbody tr:hover {
      background: #f8f9fa;
    }
    
    .main-content tbody tr:last-child td {
      border-bottom: none;
    }
    
    .main-content tfoot {
      background: #f8f9fa;
      font-style: italic;
      font-size: 12px;
      color: #666;
    }
    
    .main-content tfoot td {
      padding: 12px;
      background: #f8f9fa;
    }
    
    /* Encadrés avec fond coloré */
    .main-content table[style*="border: none"] td[style*="background: #f0f4ff"] {
      background: #f0f4ff !important;
    }
    
    .page-footer {
      margin-top: 40px;
      padding-top: 15px;
      border-top: 2px solid #7c3aed;
      background: white;
    }
    
    .footer-table {
      width: 100%;
      border: none;
      background: white;
    }
    
    .footer-table td {
      border: none;
      padding: 5px;
      vertical-align: middle;
      text-align: center;
      background: white;
    }
    
    .footer-text {
      color: #666;
      font-size: 11px;
      margin-top: 5px;
    }
    
    .no-gradient {
      color: #7c3aed;
      font-weight: normal;
    }
    
    /* Styles pour Word */
    @media print {
      body {
        background: white;
        color: #333;
      }
      
      .main-content table {
        box-shadow: none;
      }
    }
    
    /* Fix pour Word - forcer le fond blanc sur le body et html */
    @page {
      background: white;
    }
  </style>
</head>
<body bgcolor="white" style="background-color: white;">
  <!-- Header avec tableau pour meilleure compatibilité Word -->
  <div class="page-header">
    <table class="header-table" cellpadding="0" cellspacing="0">
      <tr>
        <td class="logo-cell">
          <img src="${config.url_logo}" alt="ChatInnov" width="100" height="35" style="display: block;">
        </td>
        <td class="title-cell">
          <h1>${config.marketTitle}</h1>
          <div class="date-info">
            <strong>${t.report.generationDate} :</strong> ${dateStr} ${t.report.at} ${timeStr}
          </div>
        </td>
        <td class="tagline-cell">
          <div class="tagline-text">${config.presentation_text}</div>
        </td>
      </tr>
    </table>
  </div>
  
  <!-- Contenu principal -->
  <div class="main-content">
    ${htmlContent}
  </div>
  
  <!-- Footer avec tableau -->
  <div class="page-footer">
    <table class="footer-table" cellpadding="0" cellspacing="0">
      <tr>
        <td>
          <img src="${config.url_logo}" alt="ChatInnov" width="80" height="28" style="display: block; margin: 0 auto;">
          <div class="footer-text">${t.report.generatedBy}</div>
        </td>
      </tr>
    </table>
  </div>
</body>
</html>`;
  
  return html;
};
      // Fonction pour générer le Markdown
      const generateMarkdown = () => {
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US') + 
                       ' ' + t.report.at + ' ' + 
                       date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US');
        
        let md = `# ${config.marketTitle}\n\n`;
        md += `> ${config.presentation_text}\n\n`;
        md += `**${t.report.generationDate} :** ${dateStr}\n\n`;
        md += `---\n\n`;
        
        let content = config.content;
        
        if (content.includes('<')) {
          content = content.replace(/<table[^>]*>.*?<\/table>/gis, (match) => {
            return tableToMarkdown(match);
          });
          
          content = content
            .replace(/<h1[^>]*>(.*?)<\/h1>/gi, '# $1\n\n')
            .replace(/<h2[^>]*>.*?🔷.*?<\/span>\s*(.*?)<\/h2>/gi, '## 🔷 $1\n\n')
            .replace(/<h3[^>]*>.*?🔹.*?<\/span>\s*(.*?)<\/h3>/gi, '### 🔹 $1\n\n')
            .replace(/<h4[^>]*>(.*?)<\/h4>/gi, '#### $1\n\n')
            .replace(/<strong[^>]*>(.*?)<\/strong>/gi, '**$1**')
            .replace(/<b[^>]*>(.*?)<\/b>/gi, '**$1**')
            .replace(/<em[^>]*>(.*?)<\/em>/gi, '*$1*')
            .replace(/<i[^>]*>(.*?)<\/i>/gi, '*$1*')
            .replace(/<a[^>]*href="([^"]*)"[^>]*>(.*?)<\/a>/gi, (match, url, text) => {
              return `${text} (${url})`;
            })
            .replace(/<br[^>]*>/gi, '\n')
            .replace(/<p[^>]*>(.*?)<\/p>/gi, '$1\n\n')
            .replace(/<li[^>]*>(.*?)<\/li>/gi, '- $1\n')
            .replace(/<ul[^>]*>|<\/ul>/gi, '')
            .replace(/<ol[^>]*>|<\/ol>/gi, '')
            .replace(/<span[^>]*class="no-gradient"[^>]*>(.*?)<\/span>/gi, '$1')
            .replace(/<img[^>]*src="([^"]*)"[^>]*alt="([^"]*)"[^>]*>/gi, '![$2]($1)\n\n')
            .replace(/<div[^>]*style[^>]*>.*?<\/div>/gis, function(match) {
              const content = match.replace(/<[^>]+>/g, '');
              return `\n> ${content}\n\n`;
            })
            .replace(/<[^>]+>/g, '');
        } else {
          const lines = content.split('\n');
          let inTable = false;
          let tableData = [];
          let processedContent = [];
          
          lines.forEach((line, index) => {
            if (line.includes('\t') && !inTable) {
              inTable = true;
              tableData = [];
            }
            
            if (inTable) {
              if (line.includes('\t')) {
                tableData.push(line.split('\t').map(cell => cell.trim()));
              } else if (line.trim() === '' || !line.includes('\t')) {
                if (tableData.length > 0) {
                  processedContent.push('| ' + tableData[0].join(' | ') + ' |');
                  processedContent.push('| ' + tableData[0].map(() => '---').join(' | ') + ' |');
                  
                  for (let i = 1; i < tableData.length; i++) {
                    processedContent.push('| ' + tableData[i].join(' | ') + ' |');
                  }
                  processedContent.push('');
                }
                inTable = false;
                if (line.trim() !== '') {
                  processedContent.push(line);
                }
              }
            } else {
              line = line.trim();
              if (!line) {
                processedContent.push('');
              } else if (line.startsWith('🔷')) {
                processedContent.push(`## ${line}\n`);
              } else if (line.startsWith('🔹')) {
                processedContent.push(`### ${line}\n`);
              } else if (/^\d+\./.test(line) && line.length < 100) {
                processedContent.push(`#### ${line}\n`);
              } else if (line.startsWith('•') || line.startsWith('-')) {
                processedContent.push(`- ${line.substring(1).trim()}`);
              } else {
                line = line.replace(/([A-Za-z]+)\s*–\s*([^(]+)\s*\(([^)]+)\)/g, '$1 – $2 ($3)');
                processedContent.push(line);
              }
            }
          });
          
          content = processedContent.join('\n');
        }
        
        md += content;
        md += `\n\n---\n\n*${t.report.generatedByShort}*`;
        
        return md;
      };

      // Fonction pour générer le PDF
      const generatePDF = async () => {
        if (!window.jspdf) {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          document.head.appendChild(script);
          await new Promise(resolve => script.onload = resolve);
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          unit: 'mm',
          format: 'a4',
          orientation: 'portrait'
        });
        
        doc.setFont('helvetica');
        
        let yPosition = 20;
        const pageHeight = doc.internal.pageSize.height;
        const pageWidth = doc.internal.pageSize.width;
        const margin = 20;
        const lineHeight = 7;
        const maxWidth = pageWidth - 2 * margin;
        
        // Charger le logo
        const logoBase64 = await loadImageAsBase64(config.url_logo);
        
        // Header avec logo
        doc.setFillColor(255, 255, 255);
        doc.rect(0, 0, pageWidth, 30, 'F');
        
        if (logoBase64) {
          doc.addImage(logoBase64, 'PNG', margin, 10, 30, 10);
        }
        
        // Tagline
        doc.setFontSize(8);
        doc.setTextColor(124, 58, 237);
        const taglineLines = doc.splitTextToSize(config.presentation_text, maxWidth - 40);
        taglineLines.forEach((line, index) => {
          doc.text(line, pageWidth - margin, 15 + (index * 4), { align: 'right' });
        });
        
        // Bannière héros
        doc.setFillColor(124, 58, 237);
        doc.rect(0, 30, pageWidth, 40, 'F');
        
        // Titre
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(18);
        const titleLines = doc.splitTextToSize(config.marketTitle, maxWidth);
        titleLines.forEach((line, index) => {
          doc.text(line, margin, 45 + (index * 8));
        });
        
        // Date
        doc.setFontSize(10);
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US') + 
                       ' ' + t.report.at + ' ' + 
                       date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US');
        doc.text(dateStr, margin, 62);
        
        yPosition = 85;
        
        // Contenu principal
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(11);
        
        // Parser le HTML et éviter les doublons
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = config.content;
        
        // Créer un Set pour stocker le contenu déjà traité et éviter les doublons
        const processedContent = new Set();
        
        const processNode = async (node) => {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent.trim();
            if (text && !processedContent.has(text)) {
              processedContent.add(text);
              return text;
            }
            return '';
          }
          
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName.toLowerCase();
            const textContent = node.textContent.trim();
            
            // Vérifier si ce contenu a déjà été traité
            if (processedContent.has(textContent)) {
              return '';
            }
            
            processedContent.add(textContent);
            
            switch (tagName) {
              case 'h2':
                if (yPosition > pageHeight - margin - 20) {
                  doc.addPage();
                  yPosition = margin;
                }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(26, 26, 26);
                const h2Lines = doc.splitTextToSize(textContent, maxWidth);
                h2Lines.forEach(line => {
                  doc.text(line, margin, yPosition);
                  yPosition += lineHeight + 2;
                });
                doc.setDrawColor(124, 58, 237);
                doc.setLineWidth(0.5);
                doc.line(margin, yPosition - 2, margin + 40, yPosition - 2);
                yPosition += 5;
                doc.setFont(undefined, 'normal');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(11);
                break;
                
              case 'h3':
                if (yPosition > pageHeight - margin - 15) {
                  doc.addPage();
                  yPosition = margin;
                }
                doc.setFontSize(12);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(51, 51, 51);
                const h3Lines = doc.splitTextToSize(textContent, maxWidth);
                h3Lines.forEach(line => {
                  doc.text(line, margin, yPosition);
                  yPosition += lineHeight + 1;
                });
                yPosition += 3;
                doc.setFont(undefined, 'normal');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(11);
                break;
                
              case 'p':
                if (yPosition > pageHeight - margin - 10) {
                  doc.addPage();
                  yPosition = margin;
                }
                const pLines = doc.splitTextToSize(textContent, maxWidth);
                pLines.forEach(line => {
                  doc.text(line, margin, yPosition);
                  yPosition += lineHeight;
                });
                yPosition += 3;
                break;
                
              case 'ul':
              case 'ol':
                const listItems = node.querySelectorAll('li');
                listItems.forEach(li => {
                  const liText = li.textContent.trim();
                  if (!processedContent.has(liText)) {
                    processedContent.add(liText);
                    if (yPosition > pageHeight - margin - 10) {
                      doc.addPage();
                      yPosition = margin;
                    }
                    const bullet = tagName === 'ul' ? '• ' : `${Array.from(listItems).indexOf(li) + 1}. `;
                    const liLines = doc.splitTextToSize(bullet + liText, maxWidth - 10);
                    liLines.forEach((line, index) => {
                      doc.text(line, margin + (index === 0 ? 0 : 10), yPosition);
                      yPosition += lineHeight;
                    });
                  }
                });
                yPosition += 3;
                break;
                
              case 'table':
                // Traitement des tableaux
                if (yPosition > pageHeight - margin - 30) {
                  doc.addPage();
                  yPosition = margin;
                }
                
                const caption = node.querySelector('caption');
                if (caption) {
                  doc.setFont(undefined, 'bold');
                  doc.setFontSize(10);
                  const captionText = caption.textContent.trim();
                  const captionLines = doc.splitTextToSize(captionText, maxWidth);
                  captionLines.forEach(line => {
                    doc.text(line, margin, yPosition);
                    yPosition += 6;
                  });
                  doc.setFont(undefined, 'normal');
                  doc.setFontSize(11);
                  yPosition += 2;
                }
                
                const headers = Array.from(node.querySelectorAll('thead th, tbody tr:first-child th'));
                const rows = Array.from(node.querySelectorAll('tbody tr'));
                
                if (headers.length > 0) {
                  const colCount = headers.length;
                  const colWidth = maxWidth / colCount;
                  
                  // Headers
                  doc.setFillColor(124, 58, 237);
                  doc.rect(margin, yPosition - 5, maxWidth, 8, 'F');
                  doc.setTextColor(255, 255, 255);
                  doc.setFont(undefined, 'bold');
                  doc.setFontSize(9);
                  
                  headers.forEach((header, index) => {
                    const headerText = header.textContent.trim().substring(0, Math.floor(colWidth / 2));
                    doc.text(headerText, margin + (index * colWidth) + 2, yPosition);
                  });
                  
                  yPosition += 10;
                  doc.setTextColor(0, 0, 0);
                  doc.setFont(undefined, 'normal');
                  
                  // Rows
                  rows.forEach((row, rowIndex) => {
                    if (yPosition > pageHeight - margin - 10) {
                      doc.addPage();
                      yPosition = margin;
                    }
                    
                    const cells = row.querySelectorAll('td');
                    if (cells.length > 0) {
                      if (rowIndex % 2 === 0) {
                        doc.setFillColor(248, 249, 250);
                        doc.rect(margin, yPosition - 4, maxWidth, 6, 'F');
                      }
                      
                      cells.forEach((cell, cellIndex) => {
                        const cellText = cell.textContent.trim().substring(0, Math.floor(colWidth / 2));
                        doc.text(cellText, margin + (cellIndex * colWidth) + 2, yPosition);
                      });
                      
                      yPosition += 6;
                    }
                  });
                }
                
                yPosition += 5;
                break;
                
              case 'img':
                // Traitement des images
                const imgSrc = node.src;
                const imgAlt = node.alt || 'Image';
                
                if (imgSrc && !processedContent.has(imgSrc)) {
                  processedContent.add(imgSrc);
                  try {
                    const imgBase64 = await loadImageAsBase64(imgSrc);
                    if (imgBase64) {
                      if (yPosition > pageHeight - margin - 60) {
                        doc.addPage();
                        yPosition = margin;
                      }
                      
                      const imgWidth = 80;
                      const imgHeight = 60;
                      const centerX = (pageWidth - imgWidth) / 2;
                      
                      doc.addImage(imgBase64, 'JPEG', centerX, yPosition, imgWidth, imgHeight);
                      yPosition += imgHeight + 5;
                      
                      // Légende de l'image
                      if (imgAlt) {
                        doc.setFontSize(9);
                        doc.setTextColor(100);
                        doc.setFont(undefined, 'italic');
                        doc.text(imgAlt, pageWidth / 2, yPosition, { align: 'center' });
                        yPosition += 8;
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(0);
                        doc.setFontSize(11);
                      }
                    }
                  } catch (error) {
                    console.error('Erreur lors du chargement de l\'image:', error);
                  }
                }
                break;
            }
          }
        };
        
        // Traiter tous les noeuds enfants
        for (const child of tempDiv.children) {
          await processNode(child);
        }
        
        // Footer
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          doc.setPage(i);
          doc.setFontSize(9);
          doc.setTextColor(150);
          doc.text(t.report.generatedBy, pageWidth / 2, pageHeight - 10, { align: 'center' });
          doc.text(`${i} / ${totalPages}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
        }
        
        return doc;
      };

      // Fonction pour générer le DOCX (version simplifiée - HTML avec extension .doc)
      const generateDOCX = async () => {
        const html = generateHTML();
        const blob = new Blob([html], { type: 'application/msword' });
        return blob;
      };

      // Nouvelle fonction pour générer du RTF (format compatible Word)
      const generateRTF = async () => {
        const date = new Date();
        const dateStr = date.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US') + 
                       ' ' + t.report.at + ' ' + 
                       date.toLocaleTimeString(lang === 'fr' ? 'fr-FR' : 'en-US');

        let rtf = '{\\rtf1\\ansi\\ansicpg1252\\deff0 {\\fonttbl{\\f0 Times New Roman;}}';
        rtf += '\\viewkind4\\uc1\\pard\\f0\\fs24';
        
        // Titre
        rtf += '\\qc\\b\\fs36 ' + escapeRTF(config.marketTitle) + '\\b0\\fs24\\par\\par';
        
        // Date
        rtf += '\\qc ' + escapeRTF(`${t.report.generationDate}: ${dateStr}`) + '\\par\\par';
        
        // Ligne de séparation
        rtf += '\\pard\\qc\\emdash\\emdash\\emdash\\emdash\\emdash\\emdash\\emdash\\emdash\\emdash\\emdash\\par\\par';
        
        // Contenu principal
        rtf += '\\pard\\ql\\fs22';
        
        // Parser le contenu
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = config.content;
        
        const processNodeRTF = (node) => {
          if (node.nodeType === Node.TEXT_NODE) {
            return escapeRTF(node.textContent);
          }
          
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName.toLowerCase();
            let result = '';
            
            switch (tagName) {
              case 'h2':
                result = '\\par\\b\\fs28 ' + escapeRTF(node.textContent) + '\\b0\\fs22\\par\\par';
                break;
              case 'h3':
                result = '\\par\\b\\fs26 ' + escapeRTF(node.textContent) + '\\b0\\fs22\\par\\par';
                break;
              case 'h4':
                result = '\\par\\b\\fs24 ' + escapeRTF(node.textContent) + '\\b0\\fs22\\par\\par';
                break;
              case 'p':
                result = escapeRTF(node.textContent) + '\\par\\par';
                break;
              case 'ul':
              case 'ol':
                const items = node.querySelectorAll('li');
                items.forEach((li, index) => {
                  const bullet = tagName === 'ul' ? '\\bullet ' : (index + 1) + '. ';
                  result += bullet + escapeRTF(li.textContent) + '\\par';
                });
                result += '\\par';
                break;
              case 'table':
                // Traitement simplifié des tableaux
                result += '\\par{\\trowd\\trgaph180';
                const rows = node.querySelectorAll('tr');
                const firstRow = rows[0];
                const cellCount = firstRow ? firstRow.querySelectorAll('th, td').length : 0;
                
                // Définir les colonnes
                for (let i = 0; i < cellCount; i++) {
                  const cellWidth = Math.floor(9000 / cellCount); // 9000 twips = largeur de page approx
                  result += `\\cellx${(i + 1) * cellWidth}`;
                }
                
                // Traiter chaque ligne
                rows.forEach((row, rowIndex) => {
                  const cells = row.querySelectorAll('th, td');
                  cells.forEach((cell, cellIndex) => {
                    const isHeader = cell.tagName.toLowerCase() === 'th';
                    if (isHeader) {
                      result += '\\intbl\\b ' + escapeRTF(cell.textContent) + '\\b0';
                    } else {
                      result += '\\intbl ' + escapeRTF(cell.textContent);
                    }
                    if (cellIndex < cells.length - 1) {
                      result += '\\cell ';
                    }
                  });
                  result += '\\row ';
                });
                result += '}\\par\\par';
                break;
              case 'strong':
              case 'b':
                result = '\\b ' + escapeRTF(node.textContent) + '\\b0 ';
                break;
              case 'em':
              case 'i':
                result = '\\i ' + escapeRTF(node.textContent) + '\\i0 ';
                break;
              default:
                // Pour les autres éléments, traiter les enfants
                for (const child of node.childNodes) {
                  result += processNodeRTF(child);
                }
            }
            
            return result;
          }
          
          return '';
        };
        
        // Traiter tous les noeuds
        for (const child of tempDiv.children) {
          rtf += processNodeRTF(child);
        }
        
        // Footer
        rtf += '\\par\\par\\pard\\qc\\fs18\\i ' + escapeRTF(t.report.generatedBy) + '\\i0\\fs22\\par';
        
        rtf += '}';
        
        return rtf;
      };

      // Fonction helper pour échapper les caractères spéciaux RTF (corrigée)
      const escapeRTF = (text) => {
        return text
          .replace(/\\/g, '\\\\')
          .replace(/\{/g, '\\{')
          .replace(/\}/g, '\\}')
          .replace(/\n/g, '\\par ')
          // Caractères accentués
          .replace(/[àáâãäå]/g, "\\'e0")
          .replace(/[èéêë]/g, "\\'e8")
          .replace(/[ìíîï]/g, "\\'ec")
          .replace(/[òóôõö]/g, "\\'f2")
          .replace(/[ùúûü]/g, "\\'f9")
          .replace(/[ÀÁÂÃÄÅ]/g, "\\'c0")
          .replace(/[ÈÉÊË]/g, "\\'c8")
          .replace(/[ÌÍÎÏ]/g, "\\'cc")
          .replace(/[ÒÓÔÕÖ]/g, "\\'d2")
          .replace(/[ÙÚÛÜ]/g, "\\'d9")
          .replace(/ç/g, "\\'e7")
          .replace(/Ç/g, "\\'c7")
          .replace(/ñ/g, "\\'f1")
          .replace(/Ñ/g, "\\'d1")
          // Caractères spéciaux
          .replace(/€/g, "\\'80")
          .replace(/'/g, "\\'92")
          .replace(/'/g, "\\'92")
          .replace(/"/g, "\\'93")
          .replace(/"/g, "\\'94")
          .replace(/–/g, "\\'96")
          .replace(/—/g, "\\'97")
          .replace(/…/g, "\\'85")
          .replace(/•/g, "\\'95")
          // Emojis et symboles
          .replace(/🔷/g, '[>] ')
          .replace(/🔹/g, '[>] ')
          .replace(/✓/g, '[OK] ')
          .replace(/✔/g, '[OK] ')
          .replace(/✅/g, '[OK] ')
          .replace(/❌/g, '[X] ')
          .replace(/⚠️/g, '[!] ')
          .replace(/📌/g, '[*] ')
          .replace(/🎯/g, '[o] ')
          .replace(/💡/g, '[i] ')
          // Autres caractères Unicode qui pourraient poser problème
          .replace(/[\u0080-\u00FF]/g, function(match) {
            return '\\' + "'" + match.charCodeAt(0).toString(16);
          })
          .replace(/[\u0100-\uFFFF]/g, function(match) {
            return '\\u' + match.charCodeAt(0) + '?';
          });
      };

      // Fonction pour vérifier la position du menu
      const checkMenuPosition = (menu, button) => {
        const buttonRect = button.getBoundingClientRect();
        const menuHeight = 150; // Hauteur estimée du menu
        
        // Si le menu risque de sortir en haut de l'écran
        if (buttonRect.top < menuHeight) {
          menu.classList.add('menu-below');
        } else {
          menu.classList.remove('menu-below');
        }
      };

      // BOUTON COPIER
      if (config.showCopyButton) {
        const copyWrapper = document.createElement('div');
        copyWrapper.className = 'action-button-wrapper';

        const copyButton = document.createElement('button');
        copyButton.className = 'action-button';
        copyButton.innerHTML = `<span class="action-button-icon">${config.copyIconText}</span>`;
        copyButton.title = t.copy.buttonTitle;

        const copyMenu = document.createElement('div');
        copyMenu.className = 'action-menu';
        
        const htmlOption = document.createElement('button');
        htmlOption.className = 'action-menu-option';
        htmlOption.innerHTML = `
          <span class="action-menu-option-icon">🎨</span>
          <span>${t.copy.formatOption}</span>
        `;
        htmlOption.title = t.copy.formatTooltip;
        
        const textOption = document.createElement('button');
        textOption.className = 'action-menu-option';
        textOption.innerHTML = `
          <span class="action-menu-option-icon">📝</span>
          <span>${t.copy.rawOption}</span>
        `;
        textOption.title = t.copy.rawTooltip;
        
        copyMenu.appendChild(htmlOption);
        copyMenu.appendChild(textOption);

        const copyContent = async (format = 'formatted') => {
          try {
            let textToCopy = '';
            
            if (format === 'formatted') {
              // Formaté = texte sans HTML
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = config.content;
              textToCopy = tempDiv.textContent || tempDiv.innerText || '';
            } else {
              // Brut = HTML avec toutes les balises
              textToCopy = config.content;
            }
            
            await navigator.clipboard.writeText(textToCopy);
            
            copyButton.classList.add('copied');
            copyButton.querySelector('.action-button-icon').textContent = config.copiedIcon;
            
            showToast(format === 'formatted' ? t.copy.toastFormatted : t.copy.toastRaw);
            
            setTimeout(() => {
              copyButton.classList.remove('copied');
              copyButton.querySelector('.action-button-icon').textContent = config.copyIconText;
            }, 2000);
            
          } catch (err) {
            console.error('Erreur de copie:', err);
            showToast(t.copy.toastError);
          }
        };

        copyButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!copyMenuVisible) {
            checkMenuPosition(copyMenu, copyButton);
            copyMenu.classList.add('show');
            copyMenuVisible = true;
            const downloadMenu = container.querySelector('.download-menu');
            if (downloadMenu) downloadMenu.classList.remove('show');
            downloadMenuVisible = false;
          } else {
            copyMenu.classList.remove('show');
            copyMenuVisible = false;
          }
        });

        htmlOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          copyContent('formatted');
          copyMenu.classList.remove('show');
          copyMenuVisible = false;
        });

        textOption.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          copyContent('raw');
          copyMenu.classList.remove('show');
          copyMenuVisible = false;
        });

        copyWrapper.appendChild(copyButton);
        copyWrapper.appendChild(copyMenu);
        container.appendChild(copyWrapper);
      }

      // BOUTON TÉLÉCHARGER
      if (config.showDownloadButton) {
        const downloadWrapper = document.createElement('div');
        downloadWrapper.className = 'action-button-wrapper';

        const downloadButton = document.createElement('button');
        downloadButton.className = 'action-button';
        downloadButton.innerHTML = `<span class="action-button-icon">${config.downloadIconText}</span>`;
        downloadButton.title = t.download.buttonTitle;

        const downloadMenu = document.createElement('div');
        downloadMenu.className = 'action-menu download-menu';

        const formatIcons = {
          html: '🌐',
          pdf: '📄',
          md: '📝',
          docx: '📃'
        };

        const formatLabels = {
          html: 'HTML',
          pdf: 'PDF',
          md: 'Markdown',
          docx: 'Word'
        };

        config.formats.forEach(format => {
          const option = document.createElement('button');
          option.className = 'action-menu-option';
          option.innerHTML = `
            <span class="action-menu-option-icon">${formatIcons[format]}</span>
            <span>${formatLabels[format]}</span>
          `;
          option.addEventListener('click', () => downloadReport(format));
          downloadMenu.appendChild(option);
        });

        const downloadReport = async (format) => {
          downloadButton.classList.add('generating');
          downloadButton.querySelector('.action-button-icon').textContent = '⏳';
          downloadMenu.classList.remove('show');
          downloadMenuVisible = false;
          
          try {
            const date = new Date().toISOString().slice(0, 10);
            const fileName = `${config.fileName}_${date}`;
            
            switch(format) {
              case 'html':
                const htmlContent = generateHTML();
                const htmlBlob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const htmlUrl = URL.createObjectURL(htmlBlob);
                window.open(htmlUrl, '_blank');
                setTimeout(() => {
                  URL.revokeObjectURL(htmlUrl);
                }, 1000);
                showToast(t.download.toastHTML);
                break;
                
              case 'md':
                const mdContent = generateMarkdown();
                const mdBlob = new Blob([mdContent], { type: 'text/markdown;charset=utf-8' });
                const mdUrl = URL.createObjectURL(mdBlob);
                const mdLink = document.createElement('a');
                mdLink.href = mdUrl;
                mdLink.download = `${fileName}.md`;
                mdLink.click();
                URL.revokeObjectURL(mdUrl);
                showToast(t.download.toastMarkdown);
                break;
                
              case 'pdf':
                const pdf = await generatePDF();
                pdf.save(`${fileName}.pdf`);
                showToast(t.download.toastPDF);
                break;
                
              case 'docx':
                const docxBlob = await generateDOCX();
                const docxUrl = URL.createObjectURL(docxBlob);
                const docxLink = document.createElement('a');
                docxLink.href = docxUrl;
                docxLink.download = `${fileName}.doc`; // Utiliser .doc au lieu de .docx
                docxLink.click();
                URL.revokeObjectURL(docxUrl);
                showToast(t.download.toastDOCX);
                break;
            }
            
            console.log(`✅ Rapport ${format.toUpperCase()} généré : ${fileName}`);
            
          } catch (error) {
            console.error('❌ Erreur de génération:', error);
            showToast(t.download.toastError);
          } finally {
            downloadButton.classList.remove('generating');
            downloadButton.querySelector('.action-button-icon').textContent = config.downloadIconText;
          }
        };

        downloadButton.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (!downloadMenuVisible) {
            checkMenuPosition(downloadMenu, downloadButton);
            downloadMenu.classList.add('show');
            downloadMenuVisible = true;
            const copyMenu = container.querySelector('.action-menu:not(.download-menu)');
            if (copyMenu) copyMenu.classList.remove('show');
            copyMenuVisible = false;
          } else {
            downloadMenu.classList.remove('show');
            downloadMenuVisible = false;
          }
        });

        downloadWrapper.appendChild(downloadButton);
        downloadWrapper.appendChild(downloadMenu);
        container.appendChild(downloadWrapper);
      }

      // Événement global pour fermer les menus
      document.addEventListener('click', (e) => {
        if (!container.contains(e.target)) {
          container.querySelectorAll('.action-menu').forEach(menu => {
            menu.classList.remove('show');
          });
          copyMenuVisible = false;
          downloadMenuVisible = false;
        }
      });

      element.appendChild(container);
      
      setTimeout(() => {
        const parentMessage = element.closest('.vfrc-message');
        if (parentMessage) {
          parentMessage.style.background = 'transparent';
          parentMessage.style.padding = '0';
          parentMessage.style.margin = '0';
          parentMessage.style.border = 'none';
          parentMessage.style.boxShadow = 'none';
        }
      }, 0);
      
      console.log('✅ DownloadReport multilingue prêt avec support DOCX/RTF amélioré');
      
    } catch (error) {
      console.error('❌ DownloadReport Error:', error);
    }
  }
};

export default DownloadReport;
